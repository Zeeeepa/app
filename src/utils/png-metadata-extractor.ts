/**
 * PNG Metadata Extractor for ComfyUI workflows
 * Extracts workflow metadata from PNG images generated by ComfyUI
 */

interface PNGMetadata {
  [key: string]: string | undefined;
}

/**
 * Extracts metadata from a PNG file
 */
export async function extractPNGMetadata(file: File): Promise<PNGMetadata> {
  if (!file.type.startsWith("image/png")) {
    throw new Error("File must be a PNG image");
  }

  const arrayBuffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(arrayBuffer);

  // Check PNG signature
  const pngSignature = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
  for (let i = 0; i < pngSignature.length; i++) {
    if (uint8Array[i] !== pngSignature[i]) {
      throw new Error("Invalid PNG file");
    }
  }

  const metadata: PNGMetadata = {};
  let offset = 8; // Skip PNG signature

  while (offset < uint8Array.length) {
    // Read chunk length (4 bytes, big-endian)
    const length =
      (uint8Array[offset] << 24) |
      (uint8Array[offset + 1] << 16) |
      (uint8Array[offset + 2] << 8) |
      uint8Array[offset + 3];
    offset += 4;

    // Read chunk type (4 bytes)
    const type = String.fromCharCode(
      uint8Array[offset],
      uint8Array[offset + 1],
      uint8Array[offset + 2],
      uint8Array[offset + 3],
    );
    offset += 4;

    // If this is a text chunk (tEXt, zTXt, iTXt)
    if (type === "tEXt" || type === "zTXt" || type === "iTXt") {
      const chunkData = uint8Array.slice(offset, offset + length);

      if (type === "tEXt") {
        // tEXt: keyword\0text
        const nullIndex = chunkData.indexOf(0);
        if (nullIndex !== -1) {
          const keyword = new TextDecoder("latin1").decode(
            chunkData.slice(0, nullIndex),
          );
          const text = new TextDecoder("utf-8").decode(
            chunkData.slice(nullIndex + 1),
          );
          metadata[keyword] = text;
        }
      } else if (type === "iTXt") {
        // iTXt: keyword\0compression_flag\0compression_method\0language_tag\0translated_keyword\0text
        let pos = 0;
        const nullIndex = chunkData.indexOf(0, pos);
        if (nullIndex !== -1) {
          const keyword = new TextDecoder("utf-8").decode(
            chunkData.slice(pos, nullIndex),
          );
          pos = nullIndex + 1;

          const compressionFlag = chunkData[pos];
          pos += 1;

          // Skip compression method (not used currently)
          pos += 1;

          // Skip language tag
          const langNullIndex = chunkData.indexOf(0, pos);
          if (langNullIndex !== -1) {
            pos = langNullIndex + 1;

            // Skip translated keyword
            const transNullIndex = chunkData.indexOf(0, pos);
            if (transNullIndex !== -1) {
              pos = transNullIndex + 1;

              let text: string;
              if (compressionFlag === 1) {
                // Compressed text - would need zlib decompression
                // For now, skip compressed iTXt chunks
                console.warn("Compressed iTXt chunks not supported");
                text = "";
              } else {
                text = new TextDecoder("utf-8").decode(chunkData.slice(pos));
              }
              metadata[keyword] = text;
            }
          }
        }
      }
    }

    // Move to next chunk
    offset += length + 4; // data + CRC

    // Stop at IEND chunk
    if (type === "IEND") {
      break;
    }
  }

  return metadata;
}

/**
 * Extracts workflow from PNG metadata
 */
export async function extractWorkflowFromPNG(file: File): Promise<string> {
  const metadata = await extractPNGMetadata(file);

  const workflowText = metadata.workflow || metadata.Workflow;
  if (!workflowText) {
    throw new Error("No workflow metadata found in image");
  }

  try {
    // Validate JSON and return formatted
    const workflowData = JSON.parse(workflowText);
    return JSON.stringify(workflowData, null, 2);
  } catch (error) {
    throw new Error("Invalid workflow JSON in image metadata");
  }
}

/**
 * Validates if a file is a PNG image
 */
export function isPNGFile(file: File): boolean {
  return file.type === "image/png" || file.name.toLowerCase().endsWith(".png");
}
